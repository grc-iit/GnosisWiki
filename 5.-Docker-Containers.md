This is a brief guide on how to use Docker.

# 5.1. Installation

For ubuntu:
```
sudo apt install docker
```

For RHEL
```
sudo yum install docker
```

# 5.2. Docker Basics

In this section, we go through an example of a Dockerfile and how to create a
container.

## 5.2.1. Setup

First, cd into the 5.2.DockerBasics directory of the scs-tutorial.
```bash
cd scs-tutorial/5.2.DockerBasics
```

This directory contains a single file: Dockerfile

## 5.2.2. Create a Dockerfile
Below is an example [Dockerfile](../../blob/master/5.2.DockerBasics/Dockerfile)
which creates a basic Ubuntu20.04 container.
```docker
# Install ubuntu 20.04
FROM ubuntu:20.04
LABEL maintainer="llogan@hawk.iit.edu"
LABEL version="0.0"
LABEL description="An example docker image"

# Disable Prompt During Packages Installation
ARG DEBIAN_FRONTEND=noninteractive

# Update ubuntu
RUN apt update && apt install

# Install some basic packages
RUN apt install -y \
    openssh-server \
    sudo

# Set an environment variable
ENV MY_VAR=hi

# Print environment variable
RUN echo ${MY_VAR}
```

1. FROM ubuntu:20.04 indicates the OS version that docker should install.
There are other OSes, such as fedora:latest, ubuntu:latest, centos:centos8.
This can be useful for testing portability.
2. LABEL parameters are just metadata
3. RUN executes a command as if in a terminal
4. ENV sets an environment variable

## 5.2.3. Build the container image

First, the container image must be built. This will parse the Dockerfile, install the OS, and run all commands in the Dockerfile.
The syntax is as follows:
```bash
sudo docker build -t [IMAGE_NAME] [DOCKERFILE_DIR, can be a github link] -f [DOCKERFILE_NAME]
```
1. IMAGE_NAME: a semantic name for the image being built. NOTE: the name must be in snake case (i.e., no caps).
2. DOCKERFILE_DIR: the directory containing the Dockerfile.
3. DOCKERFILE_NAME: the name of the dockerfile in that directory. This is optional. Default: Dockerfile.

Let's say that our Dockerfile is located at ${HOME}/MyDockerfiles/Dockerfile.
We could build the image two ways:
```
# Option 1: a single command
sudo docker build -t myimage ${HOME}/MyDockerfiles

# Option 2: cd into the directory
cd ${HOME}/MyDockerfiles
sudo docker build -t myimage .
```

## 5.2.4. Run the container

Next, we must run the container. This will create a container from the container image. There can be multiple containers made from the same image.
The syntax is as follows:
```bash
sudo docker run [OPTIONS] [IMAGE_NAME] [COMMAND (optional)]
```
1. OPTIONS: There are many settings which docker provides. We'll go over some of them below.
2. IMAGE_NAME: The semantic name of the image to build the container from
3. COMMAND: An optional command to run within the container.

This command will create a container CONTAINER_ID from IMAGE_NAME which uses the host network to connect to the internet and download packages.

In our case, we want to make the container interactive (i.e., have a shell):
```
sudo docker run -it --name mycontainer --network host myimage
```
We use the option "-it" to specify this is an interactive session.

## 5.2.5. Interacting with the container

You can reconnect to an interactive container's shell using docker start. The syntax is as follows:
```bash
sudo docker start -i [CONTAINER_ID]
```

You can now run commands within the image.

## 5.2.6. Useful Commands
```bash
# Run a container with a shared directory between guest and host
sudo docker run -it --name [CONTAINER_ID] --mount src=[HOST_PATH],target=[CONTAINER_PATH],type=bind --network host [IMAGE_NAME]

# List all running containers
sudo docker container ls

# List all container IDs
sudo docker container ls --all

# Get interactive shell for container
sudo docker start -i [CONTAINER_ID]

# Execute command in container
docker exec [CONTAINER_ID] [COMMAND]

# Kill a running container
sudo docker stop [CONTAINER_ID]

# Delete a container
sudo docker rm [CONTAINER_ID]

# Commit the state of a container CONTAINER_ID into a new container
# COPY_CONTAINER_ID
sudo docker commit [CONTAINER_ID] [COPY_CONTAINER_ID]
```

# 5.3. Containerized Clusters

It can be useful to create clusters of Docker images for purposes of continuous
integration. In this section, we provide an example of spawning a cluster of two
nodes and executing commands in them.

## 5.3.1. Setup

First, cd into the correct tutorial directory
```bash
cd scs-tutorial/5.3.ContainerizedClusters
```

This directory contains two files:
1. Dockerfile
2. docker-compose.yml

## 5.3.1. OpenSSH-Server Dockerfile

Here we demonstrate a [Dockerfile](../../blob/master/5.3.ContainerizedClusters/Dockerfile)
which spawns an openssh-server daemon.
```dockerfile
# Install ubuntu 20.04
FROM ubuntu:20.04
LABEL maintainer="llogan@hawk.iit.edu"
LABEL version="0.0"
LABEL description="An example docker image"

# Disable Prompt During Packages Installation
ARG DEBIAN_FRONTEND=noninteractive

# Update ubuntu
RUN apt update && apt install

# Install some basic packages
RUN apt install -y \
    openssh-server \
    sudo \
    git

# Enable passwordless SSH

# Start SSHD and wait forever
RUN sshd
```

## 5.3.2. Docker Compose File

Docker compose is used to spawn multiple docker containers. This has
a separate configuration.

Below is an example of a docker-compose.yaml
```bash
version: "3"

services:
  node1:
    build: .
    links:
      - node2
    networks:
      - net
    volumes:
      - $HOME:$HOME
    hostname: node1
    stdin_open: true
    tty: true

  node2:
    build: .
    networks:
      - net
    volumes:
      - $HOME:$HOME
    hostname: node2
    stdin_open: true
    tty: true

networks:
  net:
    driver: bridge
```

The "services" section represents the set of nodes that will be spawned.
1. node1 and node2 are the names of the containers that will be spawned.
2. build: where docker-compose will search for the Dockerfile. In our case,
its the local directory. We used the default names for the Dockerfile and
docker-compose.yaml.
3. networks: label the network the containers are apart of.
"net" is not special; it is just a name, it can be anything.
4. volumes: shared directory between the host machine and guest machine.
5. hostname: the name of the host on the network. We force the containers
hostname to be equivalent to the name of the container.
6. links: enable communication between two nodes. Note, node2 doesn't specify
a link to node1. This is because links are already two-way, so it will
result in a cyclic dependency error.

## 5.3.3. Build the cluster
```
sudo docker-compose build
```

## 5.3.4. Spawn the cluster

To spawn the cluster "as a daemon", run the following command
```
sudo docker-compose up -d
```

The "-d" ensures the container will not exit immediately.

## 5.3.5. Use docker-compose to execute commands

First, we will verify node1 and node2 can be accessed:
```
sudo docker-compose exec node1 hostname
sudo docker-compose exec node2 hostname
```

These commands should print:
```bash
node1
node2
```

Next, we will try performing ssh from one node into the other.
```
sudo docker-compose exec node1 ssh node2 hostname
```
This command will execute "ssh node2 hostname" in node1.

The result of the above command should be:
```
node2
```

Lastly, you can open an interactive shell with node1 by

## 5.3.6. Shutdown the cluster
```
sudo docker-compose down
```
